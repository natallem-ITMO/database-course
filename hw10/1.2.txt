1.2. Reserve
start transaction read write isolation level snapshot;
-- Приведем пример, когда наличие фантомной записи все портит => min isolation
-- level snapshot;
-- Пусть одновременно на одно и то же место в одном рейсе регистрируются 2 
-- пользователя.
-- В фнукции одновременнно проверим их credentials и наличие свободных мест
-- на рейсе.
-- Дальше user_1 зарегистрируется на рейс (мы вернем true и завершим транзакцию,
-- закоммитив изменения)
-- Для user_2 уже проверили наличие свободных мест и выполним 
-- delete from Tickets where FlightId = flight_id and SeatNo = seat_no;
-- insert into Tickets ...
-- Таким образом удалим бронь другого пользователя, и обоим вернем true в качестве
-- результата (хотя забронировали билет только для 2го пользователя).
-- Рассмотрим аномалию косой записи (и докажем, что в данном случае она не страшна)
-- Мы меняем только таблицу Tickets (добавляем в нее данные по ключу), и при
-- реинтеграции изменений, если исходный слепок бд не был изменен, мы попытаемся
-- вставить по ключу новый билет (или поменять его), и если две такие операции 
-- будут происходить одновременно, то одна из них просто откатиться (т.к. такой 
-- же ключ уже будет) => инвариант таблицы никак не изменится => проблемы не 
-- возникнет (т.к. даже если учитывать, что кто то одновременно с нами постарается
-- удалить/отменить рейс или поменять число, мы сможешь сказать, что наше событие
-- бронирования случилось до изменения рейса/места/времени вылета и тд)