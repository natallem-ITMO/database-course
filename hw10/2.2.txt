2.2. Взаимодействие с пользователем
-- На странице регистирации при регистрации используем
-- вызов функции заменяем при вызове в бекенде на соответствующие
-- данные с фронта
create or replace function RegisterUser(user_name varchar(100), pass text)
    returns int
as
$$
declare
    user_id int;
begin
    user_id = coalesce((select max(UserId) from Users), 0) + 1;
    insert into Users (UserId,
                       UserName,
                       EncryptedPass)
    values (user_id,
            user_name,
            crypt(pass, gen_salt('md5')));
    return user_id;
end;
$$
    language plpgsql;
-- read committed т.к. RU не подходит из-за записи,
-- а неповторяемое чтение, фантомная запись, косые чтения не страшны,
-- т.к. при неудаче на стороне бекенда выполним вызов функции несколько раз
start transaction read write isolation level read committed;
select RegisterUser(:UserName, :UserPassword);
commit;
-- В результате вызова функции регистрации получим user_id и отдадим
-- его пользователю чтобы он его запомнил
-- Для входа пользователя по user_id + password используем CheckCredentials
-- из ДЗ9, (Id, Password) заменяются на бекенде
start transaction read only isolation level read committed;
select CheckCredentials(:UserId, :UserPassword);
commit;
-- На стороне бекенда будем хранить информацию о текущей сессии с пользователем,
-- когда он будет нажимать на кнопки рядом с отображаемым билетом (бекенд знает,
-- какие типы билетов мы отдавали для просмотра: забронированные или просто свободные,
-- кнопки для разных типов тоже могут быть разные)
-- то замапим нужные действия для бекенда на эти кнопки.
-- Для незарегистрированного пользователя:
--    только свободные места и анонимной покупкой
--    только свободные для регистрации (но на стороне бекенда пересылаем в форму регистрации
--       если пользователь не зарегистриован)
-- Для зарегистриванного пользователя
--    свободные места с анонимной покупкой
--    свободные места для бронирования
--    забронированные им же места для покупки
